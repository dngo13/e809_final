#! /usr/bin/env python

import rospy
import actionlib
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from geometry_msgs.msg import PoseStamped, Twist, Point, Vector3
import tf
from sensor_msgs.msg import LaserScan
from tf.transformations import euler_from_quaternion
import sys
import yaml
import move_base

import threading
from fiducial_msgs.msg import Fiducial, FiducialTransform, FiducialTransformArray


# Node 1, leader to goals ================================
# Reads the yaml file generated from previous RWA
def open_yaml():
    global recorder_path
    ws_path = sys.path[0]
    recorder_path = ws_path + "/../yaml/location_recorder.yaml"
    with open(recorder_path, 'r') as yaml_file:
        rec = yaml.safe_load_all(yaml_file)
        for item in rec:
            print(item)
    return rec
# Tell leader to go to locations from yaml
# Use /scan to tell follower to keep 0.5m behind
# Leader--------
# create and update parameter on server -> location for leader
#  ->> string: "livingroom" or list [x, y, z]
def leader_action(rec):
    print(type(rec))

#=====================================================================
# Node 2, transform camera frame to map frame, generates goal in map for follower
# Use move_base to tell follower to reach goal/follow leader
#=======================================================
# 1 - read T_camera from /fiducial transforms
# 2 - broadcast in the frame follower_tf/camera_rgb_optical_frame
# 3 - listener.lookupTransform between broadcrast frame and map

# For step #1 and #2
class FiducialBroadcast:
    def __init__(self):
        print("Initializing new FiducialBroadcast object ")
        rospy.init_node('fiducial_broadcast')
        # self.currentSeq = None
        # self.imageTime = None
        # self.tfs = {}
        self.br = tf.TransformBroadcaster()
        # self.publishLock = threading.Lock()
        # self.markerPub = rospy.Publisher('fiducials', Marker, queue_size=20)
        rospy.Subscriber('/fiducial_transforms', FiducialTransformArray, self.newTf)
        # self.posePub = rospy.Publisher("/fiducial_pose", PoseWithCovarianceStamped, queue_size=1)
        self.child_frame = "marker_frame"  # Name suggested by professor, could be any name
        self.parent_frame = "follower_tf/camera_rgb_optical_frame"
        self.translation = None
        self.rotation = None

    def publishTransform(self):

        """publish the transform when self.translation and self.rotation is not None
        """

        if self.translation and self.rotation:
            # The publishLock is optional here. I choose to comment it for now
            # self.publishLock.acquire()
            self.br.sendTransform(self.translation,
                                  self.rotation,
                                  rospy.Time.now(),  # !!! Not sure whether it should be msg.header.stamp
                                  # Tutorial2 shows rospy.Time.now() vs tutorial3 shows the latter
                                  self.child_frame,
                                  self.parent_frame)
            # self.publishLock.release()


    def newTf(self, msg):
        """
            Broadcast fiducial_transforms when a FiducialTransformArray is received

            The tutorial followed when writing this function:
            1. Write broadcaster in Python
                http://wiki.ros.org/tf/Tutorials/Writing%20a%20tf%20broadcaster%20%28Python%29
            2. Write broadcaster in C++(suggested by prof)
                http://wiki.ros.org/tf/Tutorials/Writing%20a%20tf%20broadcaster%20%28C%2B%2B%2
            3. fiducial's github:
                https://github.com/jrlandau/fiducials-1/blob/master/fiducial_slam/src/fiducial_slam.py#L173
        """
        # self.currentSeq = msg.image_seq
        # self.imageTime = msg.header.stamp
        # self.tfs = {}
        # rospy.loginfo("got tfs from image seq %d", self.currentSeq)

        for t in msg.transforms:
            tr = t.transform.translation
            rot = t.transform.rotation
            tr.z = 0    # hardcode the marker's z to be 0, otherwise the follower could never reach it
            self.translation = (tr.x, tr.y, tr.z)
            self.rotation = (rot.x, rot.y, rot.z, rot.w)
            self.publishTransform()

    def run(self):
        hz = 10.0
        rospy.loginfo("Fiducial Broadcaster started")
        rate = rospy.Rate(hz)
        while not rospy.is_shutdown():
            self.publishTransform()
            rate.sleep()
            print("Marker data:", get_marker_data()) # !!! This line should be deleted in the future. 
            """
            Currently the output looks like 
            ('Marker data:', (x: 2.33696892147
                    y: 0.842935031475
                    z: 0.302890537336, -1.5217140603660546))
            I don't know whether it's correct or not. 
            """
        self.close()
        rospy.loginfo("Fiducial Broadcaster ended")

        
# For step 3 listener.lookupTransform           
def get_marker_data():
    """Get the current pose of the marker in the map frame between 'map' and 'marker_frame'

    Return
    ----------
    The position (x, y, z) and the yaw of the marker

    """

    # parent frame for the listener
    parent_frame = "/follower_tf/odom" # it should be /map But in my frames.pdf it currently doesn't have map
    # child frame for the listener
    child_frame = '/marker_frame'

    # set up a tf listener to retrieve transform between the robot and the world
    tf_listener = tf.TransformListener()
    tf_listener.waitForTransform(parent_frame, child_frame, rospy.Time(), rospy.Duration(1.0))

    # Below is code copied from my_bot_controller: get_odom_data
    try:
        # listener to get child_frame vs parent_frame
        (trans, rot) = tf_listener.lookupTransform(parent_frame, child_frame, rospy.Time(0))
        # rotation is a list [r, p, y]
        rotation = euler_from_quaternion(rot)
    except (tf.Exception, tf.ConnectivityException, tf.LookupException):
        rospy.loginfo("TF Exception")
        return

    # return the position (x, y, z) and the yaw
    return Point(*trans), rotation[2]

if __name__ == "__main__":
    rec = open_yaml()
    node = FiducialBroadcast()
    node.run()
    # leader_action(rec)
