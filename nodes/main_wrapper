#! /usr/bin/env python

import rospy
import actionlib
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from geometry_msgs.msg import PoseStamped, Twist, Point, Vector3
import tf
from sensor_msgs.msg import LaserScan
from tf.transformations import euler_from_quaternion
import sys
import yaml
import move_base

import threading
from fiducial_msgs.msg import Fiducial, FiducialTransform, FiducialTransformArray


# Node 1, leader to goals ================================
# Reads the yaml file generated from previous RWA
def open_yaml():
    global recorder_path
    ws_path = sys.path[0]
    recorder_path = ws_path + "/../yaml/location_recorder.yaml"
    with open(recorder_path, 'r') as yaml_file:
        rec = yaml.safe_load_all(yaml_file)
        for item in rec:
            print(item)
    return rec


# Tell leader to go to locations from yaml
# Use /scan to tell follower to keep 0.5m behind
# Leader--------
# create and update parameter on server -> location for leader
#  ->> string: "livingroom" or list [x, y, z]
def leader_action(rec):
    print(type(rec))


# =====================================================================
# Node 2, transform camera frame to map frame, generates goal in map for follower
# Use move_base to tell follower to reach goal/follow leader
# =======================================================
# 1 - read T_camera from /fiducial transforms
# 2 - broadcast in the frame follower_tf/camera_rgb_optical_frame
# 3 - listener.lookupTransform between broadcrast frame and map

# For step #1 and #2
class FiducialBroadcast:
    def __init__(self):
        print("Initializing new FiducialBroadcast object ")
        rospy.init_node('fiducial_broadcast')
        # self.currentSeq = None
        # self.imageTime = None
        # self.tfs = {}
        self.br = tf.TransformBroadcaster()
        # self.publishLock = threading.Lock()
        # self.markerPub = rospy.Publisher('fiducials', Marker, queue_size=20)
        rospy.Subscriber('/fiducial_transforms', FiducialTransformArray, self.newTf)
        # self.posePub = rospy.Publisher("/fiducial_pose", PoseWithCovarianceStamped, queue_size=1)
        self.child_frame = "marker_frame"  # Name suggested by professor, could be any name
        self.parent_frame = "follower_tf/camera_rgb_optical_frame"
        self.translation = None
        self.rotation = None

        # set up a tf listener to retrieve transform between the robot and the world
        self.tf_listener = tf.TransformListener()


    def publishTransform(self):

        """publish the transform when self.translation and self.rotation is not None
        """

        if self.translation and self.rotation:
            # The publishLock is optional here. I choose to comment it for now
            # self.publishLock.acquire()
            # print(self.translation, self.rotation)
            self.br.sendTransform(self.translation,
                                  self.rotation,
                                  rospy.Time.now(),  # !!! Not sure whether it should be msg.header.stamp
                                  # Tutorial2 shows rospy.Time.now() vs tutorial3 shows the latter
                                  self.child_frame,
                                  self.parent_frame)
            # self.publishLock.release()


    def newTf(self, msg):
        """
            Broadcast fiducial_transforms when a FiducialTransformArray is received

            The tutorial followed when writing this function:
            1. Write broadcaster in Python
                http://wiki.ros.org/tf/Tutorials/Writing%20a%20tf%20broadcaster%20%28Python%29
            2. Write broadcaster in C++(suggested by prof)
                http://wiki.ros.org/tf/Tutorials/Writing%20a%20tf%20broadcaster%20%28C%2B%2B%2
            3. fiducial's github:
                https://github.com/jrlandau/fiducials-1/blob/master/fiducial_slam/src/fiducial_slam.py#L173
        """
        # self.currentSeq = msg.image_seq
        # self.imageTime = msg.header.stamp
        # self.tfs = {}
        # rospy.loginfo("got tfs from image seq %d", self.currentSeq)

        for t in msg.transforms:
            tr = t.transform.translation
            rot = t.transform.rotation
            tr.z = 0    # hardcode the marker's z to be 0, otherwise the follower could never reach it
            self.translation = (tr.x, tr.y, tr.z)
            self.rotation = (rot.x, rot.y, rot.z, rot.w)
            self.publishTransform()

    def run(self):
        hz = 10.0
        rospy.loginfo("Fiducial Broadcaster started")
        rate = rospy.Rate(hz)

        while not rospy.is_shutdown():
            self.publishTransform()
            rate.sleep()
            print("Marker data:", self.get_marker_data())
            """
            Currently the output looks like 
                ('Marker data:', (x: 2.31065995698
                y: 0.84304929187
                z: 0.305896861637, -1.5560671787703644))

            I don't know whether it's correct or not. 
            """
        self.close()
        rospy.loginfo("Fiducial Broadcaster ended")

    # For step 3 listener.lookupTransform
    def get_marker_data(self):
        """Get the current pose of the marker in the map frame between 'map' and 'marker_frame'

        Return
        ----------
        The position (x, y, z) and the yaw of the marker

        """

        # parent frame for the listener
        parent_frame = "/map"  # it should be /map But in my frames.pdf it currently doesn't have map
        # child frame for the listener
        child_frame = '/marker_frame'

        self.tf_listener.waitForTransform(parent_frame, child_frame, rospy.Time(), rospy.Duration(1.0))
        # Below is code copied from my_bot_controller: get_odom_data
        try:
            # listener to get child_frame vs parent_frame
            (trans, rot) = self.tf_listener.lookupTransform(parent_frame, child_frame, rospy.Time(0))
            # rotation is a list [r, p, y]
            rotation = euler_from_quaternion(rot)
        except (tf.Exception, tf.ConnectivityException, tf.LookupException):
            rospy.loginfo("TF Exception")
            return

        # return the position (x, y, z) and the yaw
        return Point(*trans), rotation[2]


if __name__ == "__main__":
    rec = open_yaml()
    node = FiducialBroadcast()
    node.run()
    # leader_action(rec)
